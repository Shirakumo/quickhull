(defpackage #:org.shirakumo.fraf.quickhull
  (:use #:cl #:org.shirakumo.flare.vector)
  (:export))

(in-package #:org.shirakumo.fraf.quickhull)

(defstruct (ray
            (:include vec3)
            (:constructor %ray (3d-vectors::%vx3 3d-vectors::%vy3 3d-vectors::%vz3
                                direction)))
  (direction (vec 0 0 0) :type vec3))

(defun ray (position direction)
  (%plane (vx position) (vy position) (vz position) direction))

(defstruct (plane
            (:include vec3)
            (:constructor %plane (3d-vectors::%vx3 3d-vectors::%vy3 3d-vectors::%vz3
                                  distance)))
  (distance 0.0 :type single-float))

(defun plane (normal distance)
  (%plane (vx normal) (vy normal) (vz normal)
          (etypecase distance
            (single-float distance)
            (vec3 (- (v. normal distance))))))

(defun vraysqrdist (point ray)
  (let ((diff (v- point ray)))
    (- (vsqrlength diff)
       (/ (expt (v. diff (ray-direction ray)) 2)
          (vsqrlength (ray-direction ray))))))

(defun plane-sigdist (point plane)
  (+ (v. point plane) (plane-distance plane)))

(defun triangle-normal (a b c)
  (vc (v- a c) (v- b c)))

(defun above-plane-p (point plane)
  (<= 0 (+ (plane-distance plane) (v. plane point))))

(defstruct (half-edge
            (:constructor half-edge (&optional end opp face next)))
  (end 0 :type (unsigned-byte 32))
  (opp 0 :type (unsigned-byte 32))
  (face 0 :type (unsigned-byte 32))
  (next 0 :type (unsigned-byte 32))
  (disabled-p NIL :type boolean))

(defstruct (face-data
            (:constructor face-data (index entered-from-half-edge)))
  (index 0 :type (unsigned-byte 32))
  (entered-from-half-edge 0 :type (unsigned-byte 32)))

(defstruct (face
            (:include plane)
            (:constructor face))
  (half-edge 0 :type (unsigned-byte 32))
  (farthest-point 0 :type (unsigned-byte 32))
  (farthest-point-distance 0.0 :type single-float)
  (visible-p T :type boolean)
  (in-stack-p T :type boolean)
  (disabled-p T :type boolean)
  (horizon-edges #b11 :type (unsigned-byte 8))
  (points-on-positive-side (make-array 0 :element-type '(unsigned-byte 32) :adjustable T :fill-pointer T) :type (array (unsigned-byte 32) (*))))

(defclass mesh-builder ()
  ((faces :initform (make-array 0 :adjustable T :fill-pointer T) :accessor faces)
   (half-edges :initform (make-array 0 :adjustable T :fill-pointer T) :accessor half-edges)
   (disabled-faces :initform (make-array 0 :element-type '(unsigned-byte 32) :adjustable T :fill-pointer T) :accessor disabled-faces)
   (disabled-half-edges :initform (make-array 0 :element-type '(unsigned-byte 32) :adjustable T :fill-pointer T) :accessor disabled-half-edges)))

(defmethod shared-initialize ((builder mesh-builder) slots &key a b c d)
  (when (and a b c d)
    (let ((faces (faces builder))
          (half-edges (half-edges builder)))
      (setf (fill-pointer faces) 0)
      (setf (fill-pointer half-edges) 0)
      (setf (fill-pointer (disabled-faces builder)) 0)
      (setf (fill-pointer (disabled-half-edges builder)) 0)
      (vector-push-extend (half-edge b 6 0 1) half-edges)
      (vector-push-extend (half-edge c 9 0 2) half-edges)
      (vector-push-extend (half-edge a 3 0 0) half-edges)
      (vector-push-extend (half-edge c 2 1 4) half-edges)
      (vector-push-extend (half-edge d 11 1 5) half-edges)
      (vector-push-extend (half-edge a 7 1 3) half-edges)
      (vector-push-extend (half-edge a 0 2 7) half-edges)
      (vector-push-extend (half-edge d 5 2 8) half-edges)
      (vector-push-extend (half-edge b 10 2 6) half-edges)
      (vector-push-extend (half-edge b 1 3 10) half-edges)
      (vector-push-extend (half-edge d 8 3 11) half-edges)
      (vector-push-extend (half-edge c 4 3 9) half-edges)
      (vector-push-extend (face :half-edge 0) faces)
      (vector-push-extend (face :half-edge 3) faces)
      (vector-push-extend (face :half-edge 6) faces)
      (vector-push-extend (face :half-edge 9) faces))))

(defun add-face (mesh-builder)
  (cond ((< 0 (length (disabled-faces mesh-builder)))
         (let* ((idx (vector-pop (disabled-faces mesh-builder)))
                (face (aref (faces mesh-builder) idx)))
           (setf (face-farthest-point-distance face) 0.0)
           (setf (face-disabled-p face) NIL)
           idx))
        (T
         (vector-push-extend (face) (faces mesh-builder))
         (1- (length (faces mesh-builder))))))

(defun add-half-edge (mesh-builder)
  (cond ((< 0 (length (disabled-half-edges mesh-builder)))
         (let* ((idx (vector-pop (disabled-half-edges mesh-builder)))
                (half-edge (aref (half-edges mesh-builder) idx)))
           (setf (half-edge-disabled-p half-edge) NIL)
           idx))
        (T
         (vector-push-extend (half-edge) (half-edges mesh-builder))
         (1- (length (half-edges mesh-builder))))))

(defun add-point (face points vertex eps2)
  (let ((dist (plane-sigdist (aref points vertex) face)))
    (when (and (< 0 dist) (< (* eps2 (vsqrlength (face-direction face))) (* dist dist)))
      (vector-push-extend vertex (face-points-on-positive-side face))
      (when (< (face-farthest-point-distance face) dist)
        (setf (face-farthest-point-distance face) dist)
        (setf (face-farthest-point face) vertex))
      T)))

(defun disable-face (mesh-builder index)
  (setf (disabled-p (aref (faces mesh-builder) index)) T)
  (vector-push-extend index (disabled-faces mesh-builder)))

(defun disable-half-edge (mesh-builder index)
  (setf (disabled-p (aref (half-edges mesh-builder) index)) T)
  (vector-push-extend index (disabled-half-edges mesh-builder)))

(defun face-vertices (mesh-builder face)
  (let ((half-edge (aref (half-edges mesh-builder) (face-half-edge face))))
    (loop repeat 3
          collect (half-edge-end half-edge)
          do (setf half-edge (aref (half-edges mesh-builder) (half-edge-next half-edge))))))

(defun half-edge-vertices (mesh-builder half-edge)
  (list (half-edge-end (aref (mesh-builder-half-edges mesh-builder) (half-edge-opp half-edge)))
        (half-edge-end half-edge)))

(defun face-half-edges (mesh-builder face)
  (let ((half-edge (face-half-edge face)))
    (loop repeat 3
          collect (aref (half-edges mesh-builder) half-edge)
          do (setf half-edge (half-edge-next (aref (half-edges mesh-builder) half-edge))))))

(defclass half-edge-mesh ()
  ((points :accessor points)
   (faces :accessor faces)
   (half-edges :accessor half-edges)))

(defmethod initialize-instance :after ((mesh half-edge-mesh) &key mesh-builder in-points)
  (let ((face-mapping (make-hash-table :test 'eql))
        (half-edge-mapping (make-hash-table :test 'eql))
        (vertex-mapping (make-hash-table :test 'eql))
        (points (make-array 0 :element-type 'single-float :adjustable T :fill-pointer T))
        (faces (make-array 0 :element-type '(unsigned-byte 32) :adjustable T :fill-pointer T))
        (half-edges (make-array 0 :element-type 'half-edge :adjustable T :fill-pointer T)))
    (loop for face across (faces mesh-builder)
          for i from 0
          do (unless (face-disabled-p face)
               (setf (gethash i face-mapping) (length faces))
               (vector-push-extend (face-half-edge face) faces)
               (loop for half-edge in (face-half-edges mesh-builder face)
                     for vertex = (half-edge-end half-edge)
                     do (unless (gethash vertex vertex-mapping)
                          (setf (gethash vertex vertex-mapping) (length points))
                          (vector-push-extend (aref in-points vertex) points)))))
    (loop for half-edge across (half-edges mesh-builder)
          for i from 0
          do (unless (half-edge-disabled-p half-edge)
               (setf (gethash i half-edge-mapping) (length half-edges))
               (vector-push-extend half-edge half-edges)))
    (setf (points mesh) (map '(simple-array single-float (*)) #'identity points))
    (setf (faces mesh) (map '(simple-array (unsigned-byte 32) (*))
                            (lambda (x) (gethash x half-edge-mapping))
                            faces))
    (setf (half-edges mesh) (map '(simple-array half-edge (*))
                                 (lambda (x)
                                   (half-edge (gethash (half-edge-end x) vertex-mapping)
                                              (gethash (half-edge-opp x) half-edge-mapping)
                                              (gethash (half-edge-face x) face-mapping)
                                              (gethash (half-edge-next x) half-edge-mapping)))
                                 half-edges))))

(defclass convex-hull ()
  ((vertices :accessor vertices)
   (faces :accessor faces)))

(defun sbitp (array index)
  (= 1 (sbit array index)))

(defmethod initialize-instance :after ((hull convex-hull) &key mesh-builder points)
  (let* ((vertex-index-mapping (make-hash-table :test 'eql))
         (faces (faces mesh-builder))
         (half-edges (half-edges mesh-builder))
         (vertices (make-array 0 :element-type 'single-float :adjustable T :fill-pointer T))
         (processed-faces (make-array (length faces) :element-type 'bit))
         (face-stack (loop for i from 0 below (length faces)
                           unless (face-disabled-p (aref faces i))
                           collect i))
         (indices (make-array (- (length faces) (length (disabled-faces mesh-builder)))
                              :element-type '(unsigned-byte 32)))
         (index-ptr 0))
    (loop for face-index = (pop face-stack)
          while face-index
          do (unless (sbitp processed-faces face-index)
               (setf (sbit processed-faces face-index) 1)
               (let* ((face (aref faces face-index))
                      (vertex-indices (face-vertices mesh-builder face)))
                 (loop for half-edge in (face-half-edges mesh-builder face)
                       for face = (half-edge-face (aref half-edges (half-edge-opp half-edge)))
                       do (when (and (not (sbitp processed-faces face))
                                     (not (face-disabled-p (aref faces face))))
                            (push face face-stack)))
                 (loop for vertex in vertex-indices
                       for index-offset in '(0 2 1) ;; CCW reordering
                       for mapping = (gethash vertex vertex-index-mapping)
                       do (if mapping
                              (setf (aref indices (+ index-ptr index-offset)) mapping)
                              (let ((index (truncate (length vertices) 3))
                                    (point (aref points vertex)))
                                (setf (gethash vertex vertex-index-mapping) index)
                                (setf (aref indices (+ index-ptr index-offset)) index)
                                (vector-push-extend (vx point) vertices)
                                (vector-push-extend (vy point) vertices)
                                (vector-push-extend (vz point) vertices))))
                 (incf index-ptr 3))))
    (setf (vertices hull) (coerce vertices '(simple-array single-float (*))))
    (setf (faces hull) indices)))

(defun vertices->points (vertices)
  (let ((points (make-array (truncate vertices 3))))
    (loop for v from 0 below (length vertices) by 3
          for p from 0
          do (setf (aref points p) (vec (aref vertices (+ v 0))
                                        (aref vertices (+ v 1))
                                        (aref vertices (+ v 2)))))
    points))

(defun compute-extrema (points)
  (let ((extrema (make-array 6 :element-type 'single-float))
        (indices (make-array 6 :element-type '(unsigned-byte 32))))
    (loop for point across points
          for i from 0
          do (cond ((< (aref extrema 0) (vx point)) (setf (aref extrema 0) (vx point)) (setf (aref indices 0) i))
                   ((< (vx point) (aref extrema 1)) (setf (aref extrema 1) (vx point)) (setf (aref indices 1) i)))
             (cond ((< (aref extrema 2) (vy point)) (setf (aref extrema 2) (vy point)) (setf (aref indices 2) i))
                   ((< (vy point) (aref extrema 3)) (setf (aref extrema 3) (vy point)) (setf (aref indices 3) i)))
             (cond ((< (aref extrema 4) (vz point)) (setf (aref extrema 4) (vz point)) (setf (aref indices 4) i))
                   ((< (vz point) (aref extrema 5)) (setf (aref extrema 5) (vz point)) (setf (aref indices 5) i))))
    indices))

(defun compute-scale (extrema points)
  (loop for i from 0 below (length extrema)
        for v = (aref points (aref extrema i))
        for a = (nvabs (v+ v (truncate i 2)))
        maximize a))

(defun compute-initial-mesh (points extrema eps2)
  (flet ((make-mesh-builder (a b c d)
           (make-instance 'mesh-builder :a a :b b :c c :d d)))
    (case (length points)
      ((0 1 2)
       (error "Mesh has no volume. Not enough points to form a triangle."))
      ((3 4)
       (let ((plane (plane (triangle-normal (aref points 0) (aref points 1) (aref points 2)) (aref points 0))))
         (if (above-plane-p (aref points (min 3 (length points))) plane)
             (make-mesh-builder 1 0 2 (min 3 (length points)))
             (make-mesh-builder 0 1 2 (min 3 (length points))))))
      (T
       (let (base-a base-b base-c base-d)
         (let ((max-dist eps2))
           (loop for i from 0 below (length extrema)
                 do (loop for j from (1+ i) below (length extrema)
                          for dist = (vsqrdistance (aref points (aref extrema i)) (aref points (aref extrema j)))
                          do (when (< max-dist dist)
                               (setf max-dist dist)
                               (setf base-a (aref extrema i))
                               (setf base-b (aref extrema j)))))
           (unless base-a
             (error "Mesh has no volume. All points are the same.")))
         (let ((max-dist eps2)
               (ray (ray (aref points base-a) (v- (aref points base-b) (aref points base-a)))))
           (loop for i from 0 below (length points)
                 for point = (aref points i)
                 for dist = (vraysqrdist point ray)
                 do (when (< max-dist dist)
                      (setf max-dist dist)
                      (setf base-c i)))
           (unless base-c
             (error "Mesh has no volume. All points are part of a 1-dimensional line.")))
         (let ((max-dist eps2)
               (plane (plane (triangle-normal (aref points base-a) (aref points base-b) (aref points base-c)) (aref points base-a))))
           (loop for i from 0 below (length points)
                 for point = (aref points i)
                 for dist = (plane-sigdist point plane)
                 do (when (< max-dist dist)
                      (setf max-dist dist)
                      (setf base-d i)))
           (unless base-d
             ;; FIXME: 2D case. Inject an extra point to give the mesh volume and remove the point again on finish.
             (error "Mesh has no volume. All points are part of a 2-dimensional plane."))
           (let ((mesh-builder (if (above-plane-p (aref points base-d) plane)
                                   (make-mesh-builder base-b base-a base-c base-d)
                                   (make-mesh-builder base-a base-b base-c base-d))))
             (loop for face across (faces mesh-builder)
                   for (a b c) = (face-vertices mesh-builder face)
                   for normal = (triangle-normal (aref points a) (aref points b) (aref points c))
                   do (v<- face normal)
                      (setf (face-distance face) (- (v. normal (aref points a)))))
             (dotimes (i (length points))
               (loop for face across (faces mesh-builder)
                     until (add-point face points i eps2))))))))))

(defun quickhull (vertices &key (eps 0.0001))
  (let* ((points (vertices->points vertices))
         (extrema (compute-extrema points))
         (scale (compute-scale extrema points))
         (eps (* eps scale))
         (eps2 (expt eps 2))
         (mesh-builder (compute-initial-mesh points extrema eps2))
         (faces (faces mesh-builder))
         (visible-faces (make-array 0 :element-type '(unsigned-byte 32) :adjustable T :fill-pointer T))
         (horizon-edges (make-array 0 :element-type '(unsigned-byte 32) :adjustable T :fill-pointer T))
         (possibly-visible-faces (make-array 0 :element-type '(unsigned-byte 32) :adjustable T :fill-pointer T))
         (face-list () )) ;; should be a double-ended queue
    (loop for i from 0 below 4
          for face = (aref faces i)
          do (when (< 0 (length (face-points-on-positive-side face)))
               (push i face-list)
               (setf (face-in-stack-p face) T)))
    ;; TODO
    (make-instance 'convex-hull :mesh-builder mesh-builder :vertices vertices)))
